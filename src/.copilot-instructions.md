# Copilot Instructions — src/

> These instructions supplement the root `.github/copilot-instructions.md` and apply to all source projects under `src/`.

---

## Service Architecture Patterns

Each microservice in `src/` follows one of two patterns. **Always match the pattern of the service you're working in.**

### Pattern A — Simple CRUD Service (Catalog.API, Webhooks.API, Basket.API)

- Direct `DbContext` injection into Minimal API endpoint handlers.
- No repository abstraction, no domain layer, no MediatR.
- EF Core LINQ queries directly in the handler methods.
- DTOs/records for request/response contracts.

```csharp
// ✅ Catalog-style: direct DbContext in handler
public static async Task<Ok<List<CatalogItem>>> GetItemsByIds(
    [AsParameters] CatalogServices services, int[] ids)
{
    var items = await services.Context.CatalogItems.Where(item => ids.Contains(item.Id)).ToListAsync();
    return TypedResults.Ok(items);
}
```

### Pattern B — DDD + CQRS Service (Ordering.API)

- Commands go through MediatR → Command Handlers → Domain Aggregates → Repositories → `IUnitOfWork.SaveEntitiesAsync()`.
- Queries go through `IOrderQueries` → EF Core LINQ projections.
- Domain events are dispatched by the `OrderingContext` before `SaveChangesAsync`.
- Never bypass the MediatR pipeline for writes.

```csharp
// ✅ Ordering-style: commands through MediatR
var requestCancelOrder = new IdentifiedCommand<CancelOrderCommand, bool>(command, requestId);
var commandResult = await services.Mediator.Send(requestCancelOrder);
```

---

## Entity Framework Core — Service-Specific Contexts

| Service | DbContext | Database | Provider |
|---|---|---|---|
| Catalog.API | `CatalogContext` | catalogdb | Npgsql + pgvector |
| Ordering.API | `OrderingContext` | orderingdb | Npgsql |
| Webhooks.API | `WebhooksContext` | webhooksdb | Npgsql |
| Identity.API | `ApplicationDbContext` | identitydb | Npgsql |

### DbContext Registration Patterns

```csharp
// Aspire-style (Catalog) — preferred for new services
builder.AddNpgsqlDbContext<CatalogContext>("catalogdb", configureDbContextOptions: dbContextOptionsBuilder =>
{
    dbContextOptionsBuilder.UseNpgsql(builder => builder.UseVector());
});

// Manual-style (Ordering) — when Aspire pooling isn't compatible
services.AddDbContext<OrderingContext>(options =>
{
    options.UseNpgsql(builder.Configuration.GetConnectionString("orderingdb"));
});
```

### Entity Configuration

- Use `IEntityTypeConfiguration<T>` classes in an `EntityConfigurations/` or `Infrastructure/` folder.
- Apply configurations in `OnModelCreating` via `modelBuilder.ApplyConfiguration(new FooEntityTypeConfiguration())`.
- Include `modelBuilder.UseIntegrationEventLogs()` if the service publishes integration events.

---

## Integration Events

- All integration events are `record` types inheriting from `IntegrationEvent`.
- Published through `IEventBus.PublishAsync()` (backed by RabbitMQ).
- Use the transactional outbox pattern (`IntegrationEventLogEF`) for atomicity.
- Event handlers implement `IIntegrationEventHandler<TEvent>`.
- Subscribe in `Extensions.cs` via `eventBus.AddSubscription<TEvent, THandler>()`.

---

## Aspire AppHost

- All service wiring is in `eShop.AppHost/Program.cs`.
- Use `builder.AddProject<Projects.Foo>("foo")` to register services.
- Use `.WithReference(resource)` and `.WaitFor(resource)` for dependencies.
- Use `.WithEnvironment("Key", value)` for configuration injection.
- PostgreSQL databases are added via `postgres.AddDatabase("dbname")`.

---

## Service Defaults

The `eShop.ServiceDefaults` project provides shared cross-cutting concerns. When adding a new service:

1. Call `builder.AddServiceDefaults()` in `Program.cs` — adds health checks, OpenTelemetry, service discovery, resilience.
2. Call `app.MapDefaultEndpoints()` — maps `/health` and `/alive` endpoints.
3. Call `builder.AddDefaultAuthentication()` — adds JWT bearer auth from configuration.
4. Call `builder.AddDefaultOpenApi(withApiVersioning)` — adds OpenAPI + Scalar UI.

---

## File Organization

- `Program.cs` — minimal startup; delegates to extension methods.
- `Extensions.cs` — service registration and configuration.
- `GlobalUsings.cs` — project-wide using directives.
- `Apis/` — Minimal API endpoint definitions.
- `Application/Commands/` — MediatR command + handler pairs (Ordering).
- `Application/Queries/` — Query interfaces + implementations (Ordering).
- `Application/Behaviors/` — MediatR pipeline behaviors (Ordering).
- `Application/Validations/` — FluentValidation validators (Ordering).
- `Application/DomainEventHandlers/` — Domain event handlers (Ordering).
- `Application/IntegrationEvents/` — Integration event definitions + handlers.
- `Infrastructure/` — DbContext, entity configurations, migrations.
- `Model/` — Domain/entity models (Catalog-style services).
- `Repositories/` — Repository implementations (Ordering).

---

## Files to EXCLUDE from Suggestions

- `**/Migrations/*.cs` — Generated by EF Core tooling. Never manually edit.
- `**/Migrations/*.Designer.cs` — Auto-generated. Never manually edit.
- `**/*ModelSnapshot.cs` — Auto-generated. Never manually edit.
- `**/bin/**`, `**/obj/**` — Build output.
- `**/Properties/launchSettings.json` — Launch configuration.
- `Program.Testing.cs` — Test-specific program entry points.
