# Copilot Instructions â€” Ordering Domain (DDD Bounded Context)

> These instructions apply to the Ordering bounded context: `Ordering.Domain/`, `Ordering.Infrastructure/`, and `Ordering.API/`.

---

## Domain Model Rules

### Aggregates

The Ordering domain has two aggregate roots:

1. **`Order`** (root) â†’ owns `OrderItem` (child entity), `Address` (value object)
2. **`Buyer`** (root) â†’ owns `PaymentMethod` (child entity)

### âœ… DO

- **Mutate aggregates only through methods on the aggregate root.** For example, use `order.AddOrderItem(...)`, `order.SetCancelledStatus()`, `order.SetPaidStatus()`.
- **Enforce invariants inside aggregate methods.** Throw `OrderingDomainException` for business rule violations.
- **Use private setters** on all entity properties. Expose state through read-only properties.
- **Use `List<T>` as a private backing field** with `IReadOnlyCollection<T>` as the public accessor:
  ```csharp
  private readonly List<OrderItem> _orderItems;
  public IReadOnlyCollection<OrderItem> OrderItems => _orderItems.AsReadOnly();
  ```
- **Raise domain events** via `AddDomainEvent(new FooDomainEvent(...))` inside aggregate methods.

### ðŸš« DO NOT

- Never modify child entities (`OrderItem`, `PaymentMethod`) directly from outside the aggregate root.
- Never add public setters to domain entity properties.
- Never put business logic in API handlers, command handlers, or infrastructure code â€” it belongs in the aggregate.
- Never create new aggregates without implementing `IAggregateRoot`.
- Never use `DbContext` directly in domain entities.

---

## Value Objects

- Extend the `ValueObject` base class.
- Override `GetEqualityComponents()` to define structural equality.
- Value objects are immutable â€” no public setters after construction.

```csharp
// âœ… Correct value object pattern
public class Address : ValueObject
{
    public string Street { get; private set; }
    public string City { get; private set; }
    // ...
    protected override IEnumerable<object> GetEqualityComponents()
    {
        yield return Street;
        yield return City;
        // ...
    }
}
```

---

## Domain Events

- Domain events implement `INotification` (MediatR).
- Prefer `record class` for domain events: `public record class OrderStartedDomainEvent(...) : INotification;`
- Domain events are added inside aggregate methods and dispatched by `OrderingContext.SaveEntitiesAsync()` via `MediatorExtension.DispatchDomainEventsAsync()`.
- Domain event handlers live in `Ordering.API/Application/DomainEventHandlers/`.
- Domain event handlers may publish integration events or update other aggregates.

---

## Repositories

- Repositories implement `IRepository<T>` where `T : IAggregateRoot`.
- Each repository exposes `IUnitOfWork UnitOfWork => _context;` (the `OrderingContext` implements `IUnitOfWork`).
- Use `FindAsync()` for single-entity lookups.
- Use explicit loading (`.Collection(...).LoadAsync()`) when loading child collections.
- Use `_context.Entry(entity).State = EntityState.Modified` for updates.

```csharp
// âœ… Correct repository pattern
public async Task<Order> GetAsync(int orderId)
{
    var order = await _context.Orders.FindAsync(orderId);
    if (order != null)
    {
        await _context.Entry(order)
            .Collection(i => i.OrderItems).LoadAsync();
    }
    return order;
}
```

---

## Commands (CQRS Write Side)

- Commands implement `IRequest<TResponse>`.
- Prefer `record` syntax: `public record CancelOrderCommand(int OrderNumber) : IRequest<bool>;`
- Complex commands with many properties may use `class` with `private set` (see `CreateOrderCommand`).
- Use `IdentifiedCommand<T, R>` wrapper for idempotency.
- Command handlers:
  - Retrieve the aggregate from its repository.
  - Call methods on the aggregate to execute business logic.
  - Call `UnitOfWork.SaveEntitiesAsync()` to persist and dispatch domain events.
- **Never** put business logic in command handlers â€” delegate to the aggregate.

### Validation

- Use **FluentValidation** for command validation.
- Validators are registered via `ValidatorBehavior` in the MediatR pipeline.
- Validator classes live in `Application/Validations/`.

```csharp
// âœ… FluentValidation validator
public class CreateOrderCommandValidator : AbstractValidator<CreateOrderCommand>
{
    public CreateOrderCommandValidator(ILogger<CreateOrderCommandValidator> logger)
    {
        RuleFor(command => command.City).NotEmpty();
        RuleFor(command => command.Street).NotEmpty();
        // ...
    }
}
```

---

## Queries (CQRS Read Side)

- Queries go through `IOrderQueries` interface, implemented by `OrderQueries`.
- `OrderQueries` uses `OrderingContext` with EF Core LINQ projections â€” **never raw SQL**.
- Query results use `record` view models defined in `Application/Queries/OrderViewModel.cs`:
  - `Order`, `OrderSummary`, `CardType`, `Orderitem` â€” all records with `init` properties.
- Always project into DTOs/records â€” do not return domain entities from queries.

```csharp
// âœ… Correct query pattern â€” EF Core LINQ with projection
public async Task<IEnumerable<OrderSummary>> GetOrdersFromUserAsync(string userId)
{
    return await context.Orders
        .Where(o => o.Buyer.IdentityGuid == userId)
        .Select(o => new OrderSummary
        {
            OrderNumber = o.Id,
            Date = o.OrderDate,
            Status = o.OrderStatus.ToString(),
            Total = (double)o.OrderItems.Sum(oi => oi.UnitPrice * oi.Units)
        })
        .ToListAsync();
}
```

---

## MediatR Pipeline Behaviors

The Ordering API uses three open behaviors registered in order:

1. **`LoggingBehavior<,>`** â€” Logs command execution with structured logging.
2. **`ValidatorBehavior<,>`** â€” Runs FluentValidation validators; throws `ValidationException` on failure.
3. **`TransactionBehavior<,>`** â€” Wraps command execution in a database transaction using `OrderingContext.BeginTransactionAsync()`.

When adding new behaviors, register them via `cfg.AddOpenBehavior(typeof(NewBehavior<,>))` in `Extensions.cs`.

---

## Entity Configurations

- All EF entity configurations live in `Ordering.Infrastructure/EntityConfigurations/`.
- Each aggregate/entity has its own configuration class implementing `IEntityTypeConfiguration<T>`.
- Configurations define table mappings, keys, relationships, and value object ownership.
- The `OrderingContext` uses schema `"ordering"`: `modelBuilder.HasDefaultSchema("ordering")`.

---

## Integration Events (Ordering)

- Integration events are published by domain event handlers (not by command handlers directly).
- Use `IOrderingIntegrationEventService.AddAndSaveEventAsync(event)` for outbox pattern.
- Integration event definitions live in `Application/IntegrationEvents/Events/`.
- Integration event handlers live in `Application/IntegrationEvents/EventHandling/`.
